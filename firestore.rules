
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isHost(lobbyData) {
      return request.auth.uid == lobbyData.hostId;
    }

    function isPlayer(lobbyData) {
      return request.auth.uid in lobbyData.players.map(p => p.uid);
    }

    function playerIsJoining(lobbyData) {
      let isNewPlayer = !(request.auth.uid in lobbyData.players.map(p => p.uid));
      let isJoining = request.auth.uid in request.resource.data.players.map(p => p.uid);
      return isNewPlayer && isJoining;
    }
    
    function onlyOwnPlayerDataChanged(lobbyData) {
      // For every player in the future state...
      return request.resource.data.players.forall(player ->
        // If it's the current user, they can only change their score and guesses.
        (player.uid == request.auth.uid && player.keys().hasOnly(['uid', 'displayName', 'photoURL', 'score', 'guesses'])) ||
        // If it's another player, their data must not have changed at all.
        (player.uid != request.auth.uid && player == lobbyData.players.get(lobbyData.players.indexWhere('uid', '==', player.uid)))
      );
    }


    match /lobbies/{lobbyId} {
      allow read;

      allow create: if isSignedIn()
                      && request.resource.data.hostId == request.auth.uid;

      allow update: if isSignedIn() && (
        // Case 1: The user is the host. Allow them to change game state.
        isHost(resource.data) ||
        
        // Case 2: A new player is joining a waiting lobby.
        (playerIsJoining(resource.data) && resource.data.status == 'waiting') ||

        // Case 3: An existing player is updating only their own score/guesses.
        (isPlayer(resource.data) && onlyOwnPlayerDataChanged(resource.data))
      );
    }
  }
}
